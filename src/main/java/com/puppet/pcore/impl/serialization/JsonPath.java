package com.puppet.pcore.impl.serialization;

import com.puppet.pcore.Default;
import com.puppet.pcore.impl.Polymorphic;
import com.puppet.pcore.impl.StringConverter;
import com.puppet.pcore.impl.parser.*;
import com.puppet.pcore.impl.serialization.FromDataConverter.RefEntry;
import com.puppet.pcore.impl.types.AnyType;
import com.puppet.pcore.impl.types.TypeFactory;
import com.puppet.pcore.parser.Expression;
import com.puppet.pcore.parser.ExpressionParser;
import com.puppet.pcore.parser.model.*;
import com.puppet.pcore.serialization.SerializationException;

import java.util.List;

import static java.lang.String.format;

public class JsonPath {
	public static String toJsonPath(List<?> path) {
		AnyType scalarType = TypeFactory.scalarType();
		StringConverter sc = StringConverter.singleton;
		StringBuilder bld = new StringBuilder();
		bld.append('$');
		for(Object seg : path) {
			if(seg == null)
				bld.append("[null]");
			else if(scalarType.isInstance(seg))
				bld.append('[').append(sc.convert(seg, "%p")).append(']');
			else
				// Unable to construct json path from complex segments
				return null;
		}
		return bld.toString();
	}

	/**
	 * Resolve the given <code>path</code> in the given <code>context</code>.
	 *
	 * @param context the context used for resolution
	 * @param path the json path
	 * @return the resolvedEntries value
	 */
	public static Object resolve(RefEntry context, String path) {
		return Resolver.singleton.resolve(context, path);
	}

	/**
	 * Resolver for JSON path that uses the Puppet parser to create the AST. The path must start
	 * with '$' which denotes the value that is passed into the parser. This parser can easily
	 * be extended with more elaborate resolution mechanisms involving document sets.
	 *
	 * The parser is limited to constructs generated by the {@link JsonPath#toJsonPath(List)}
	 * method.
	 */
	static class Resolver extends Polymorphic<Object> {
		private static final DispatchMap dispatchMap = initPolymorphicDispatch(Resolver.class, "resolve", 2);

		@Override
		protected DispatchMap getDispatchMap() {
			return dispatchMap;
		}

		public static final Resolver singleton = new Resolver();

		private final ExpressionParser parser = new Parser();

		private Resolver() {
		}

		public Object resolve(RefEntry context, String path) {
			Expression expr = parser.parse(null, path, false, true);
			Object resolved = dispatch(expr, context, path);
			return resolved instanceof RefEntry ? ((RefEntry)resolved).getValue() : resolved;
		}

		Object resolve(AccessExpression ast, RefEntry context, String path) {
			if(ast.keys.size() != 1)
				throw badJsonPath(path);

			Object receiver = dispatch(ast.operand, context, path);
			return resolveAccess(receiver, dispatch(ast.keys.get(0), context, path), path);
		}

		Object resolve(NamedAccessExpression ast, RefEntry context, String path) {
			return resolveAccess(dispatch(ast.lhs, context, path), dispatch(ast.rhs, context, path), path);
		}

		Object resolve(QualifiedReference ast, RefEntry context, String path) {
			String name = ast.name;
			return name.equalsIgnoreCase("null") ? null : name;
		}

		Object resolve(QualifiedName ast, RefEntry context, String path) {
			String name = ast.name;
			return name.equalsIgnoreCase("null") ? null : name;
		}

		Object resolve(LiteralExpression ast, RefEntry context, String path) {
			Object v = ast.value();
			if(v == null)
				return "undef";
			if(v == Default.SINGLETON)
				return "default";
			return v;
		}

		Object resolve(VariableExpression ast, RefEntry context, String path) {
	    // A single '$' means root, i.e. the context.
			if(dispatch(ast.expr, context, path).equals(""))
				return context;
			throw badJsonPath(path);
		}

		private Object resolveAccess(Object receiver, Object key, String path) {
			if(receiver instanceof RefEntry)
				return ((RefEntry)receiver).get(key);

			throw badJsonPath(path);
		}

		private static SerializationException badJsonPath(String path) {
			return new SerializationException(format("Unable to parse jsonpath '%s'", path));
		}
	}
}
